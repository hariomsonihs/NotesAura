[
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Basics",
    "question": "What is Java?",
    "answer": "Java is a high-level, object-oriented, and platform-independent programming language.",
    "details": "Java is widely used for building mobile apps (Android), web apps, desktop apps, and enterprise software. Java follows the concept of 'Write Once, Run Anywhere' because Java code runs on the JVM (Java Virtual Machine).",
    "example_code": "Not required"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Basics",
    "question": "Why is Java platform independent?",
    "answer": "Java is platform independent because it compiles into bytecode that runs on JVM.",
    "details": "Java compiler converts source code into bytecode (.class file). JVM on different operating systems executes the same bytecode, making Java platform independent.",
    "example_code": "Not required"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Basics",
    "question": "What is the difference between JDK, JRE, and JVM?",
    "answer": "JDK is for development, JRE is for running Java apps, and JVM executes bytecode.",
    "details": "JDK (Java Development Kit) contains tools like compiler (javac). JRE (Java Runtime Environment) provides libraries and JVM to run programs. JVM (Java Virtual Machine) is responsible for executing bytecode.",
    "example_code": "Not required"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Basics",
    "question": "What is the use of public static void main(String[] args) in Java?",
    "answer": "It is the entry point of a Java program.",
    "details": "public: accessible by JVM, static: no object needed to call, void: returns nothing, main: execution starts here, String[] args: stores command-line arguments.",
    "example_code": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello Java!\");\n    }\n}"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Basics",
    "question": "What are variables in Java?",
    "answer": "Variables are used to store data values.",
    "details": "Java variables are containers for storing values during runtime. Types include local variables, instance variables, and static variables.",
    "example_code": "int age = 20;\nString name = \"Hariom\";\ndouble salary = 25000.50;"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Basics",
    "question": "What are primitive data types in Java?",
    "answer": "byte, short, int, long, float, double, char, boolean",
    "details": "Primitive data types store simple values directly and are not objects. They occupy fixed memory sizes.",
    "example_code": "int a = 10;\ndouble d = 12.5;\nchar ch = 'A';\nboolean isJavaFun = true;"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Basics",
    "question": "What is type casting in Java?",
    "answer": "Type casting converts one data type into another.",
    "details": "Type casting is of two types: Widening (implicit) and Narrowing (explicit). Widening happens automatically, while narrowing requires manual casting.",
    "example_code": "int a = 10;\ndouble b = a; // Widening\n\ndouble x = 10.99;\nint y = (int) x; // Narrowing"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Basics",
    "question": "What are operators in Java?",
    "answer": "Operators are symbols used to perform operations on variables and values.",
    "details": "Java provides arithmetic (+, -, *, /), relational (==, !=), logical (&&, ||), assignment (=), and other operators.",
    "example_code": "int a = 10, b = 5;\nSystem.out.println(a + b);\nSystem.out.println(a > b);\nSystem.out.println(a == b);"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Control Statements",
    "question": "What is the use of if-else statement in Java?",
    "answer": "if-else is used to make decisions based on conditions.",
    "details": "if-else executes a block of code when a condition is true and another block when the condition is false.",
    "example_code": "int age = 18;\nif(age >= 18) {\n    System.out.println(\"Eligible to vote\");\n} else {\n    System.out.println(\"Not eligible\");\n}"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Control Statements",
    "question": "What is a switch statement in Java?",
    "answer": "switch is used to execute one block of code among many options.",
    "details": "It is commonly used when there are multiple conditions based on a single variable value.",
    "example_code": "int day = 2;\nswitch(day) {\n    case 1: System.out.println(\"Monday\"); break;\n    case 2: System.out.println(\"Tuesday\"); break;\n    default: System.out.println(\"Invalid\");\n}"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Loops",
    "question": "What is the difference between for loop and while loop?",
    "answer": "for loop is used when the number of iterations is known, while loop is used when iterations depend on a condition.",
    "details": "for loop is compact and commonly used for fixed loops, while loop is better for indefinite loops.",
    "example_code": "// for loop\nfor(int i=1; i<=5; i++) {\n    System.out.println(i);\n}\n\n// while loop\nint j=1;\nwhile(j<=5) {\n    System.out.println(j);\n    j++;\n}"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "OOP",
    "question": "What is OOP in Java?",
    "answer": "OOP stands for Object-Oriented Programming, a programming model based on objects.",
    "details": "OOP concepts help create reusable and modular code. The main principles are Encapsulation, Inheritance, Polymorphism, and Abstraction.",
    "example_code": "Not required"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "OOP",
    "question": "What is a class in Java?",
    "answer": "A class is a blueprint for creating objects.",
    "details": "It contains fields (variables) and methods (functions) that define the behavior of objects.",
    "example_code": "class Student {\n    String name;\n    int age;\n\n    void show() {\n        System.out.println(name + \" \" + age);\n    }\n}"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "OOP",
    "question": "What is an object in Java?",
    "answer": "An object is an instance of a class.",
    "details": "Objects store state (data) and provide behavior (methods). They occupy memory in heap.",
    "example_code": "Student s = new Student();\ns.name = \"Hariom\";\ns.age = 21;\ns.show();"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "OOP",
    "question": "What is a constructor in Java?",
    "answer": "A constructor is a special method used to initialize objects.",
    "details": "Constructor name is same as class name and it has no return type. It is called automatically when object is created.",
    "example_code": "class Demo {\n    Demo() {\n        System.out.println(\"Constructor called\");\n    }\n\n    public static void main(String[] args) {\n        Demo d = new Demo();\n    }\n}"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "OOP",
    "question": "What is method overloading?",
    "answer": "Method overloading means same method name with different parameters.",
    "details": "Overloading occurs in the same class. It is compile-time polymorphism because method selection happens at compile time.",
    "example_code": "class Calc {\n    int add(int a, int b) { return a + b; }\n    int add(int a, int b, int c) { return a + b + c; }\n}"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "String",
    "question": "What is the difference between == and equals() in Java?",
    "answer": "== checks reference, equals() checks content.",
    "details": "== compares memory location, while equals() compares actual value/content of objects like Strings.",
    "example_code": "String a = new String(\"Java\");\nString b = new String(\"Java\");\n\nSystem.out.println(a == b);      // false\nSystem.out.println(a.equals(b)); // true"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "String",
    "question": "Why is String immutable in Java?",
    "answer": "String is immutable for security, performance, and thread safety.",
    "details": "String values cannot be changed after creation. Any modification creates a new object, which helps in caching and safe usage in many Java APIs.",
    "example_code": "String s = \"Hello\";\ns.concat(\" World\");\nSystem.out.println(s); // Hello (unchanged)"
  },
  {
    "category": "Java",
    "level": "Easy",
    "topic": "Exception Handling",
    "question": "What is exception handling in Java?",
    "answer": "Exception handling is used to handle runtime errors gracefully.",
    "details": "Java uses try-catch-finally blocks for handling exceptions so that the program doesn't crash unexpectedly.",
    "example_code": "try {\n    int a = 10 / 0;\n} catch (ArithmeticException e) {\n    System.out.println(\"Cannot divide by zero\");\n} finally {\n    System.out.println(\"Always runs\");\n}"
  },
  {
    "category": "java-programming",
    "level": "Basic",
    "topic": "Java Introduction",
    "question": "What is Java?",
    "answer": "Java is a high-level, object-oriented, platform-independent programming language used to develop applications for web, mobile, desktop, and enterprise systems.",
    "details": "Java follows the principle of 'Write Once, Run Anywhere' (WORA) because Java code runs on the JVM (Java Virtual Machine).",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Basic",
    "topic": "Java Features",
    "question": "What are the main features of Java?",
    "answer": "Main features of Java include Object-Oriented, Platform Independent, Secure, Robust, Multithreaded, Portable, High Performance, and Distributed.",
    "details": "Java achieves platform independence using bytecode and JVM.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Basic",
    "topic": "JDK/JRE/JVM",
    "question": "What is the difference between JDK, JRE, and JVM?",
    "answer": "JDK is the Java Development Kit used for development. JRE is the Java Runtime Environment needed to run Java programs. JVM is the Java Virtual Machine that executes bytecode.",
    "details": "JDK = JRE + development tools (compiler, debugger). JRE = JVM + libraries.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Basic",
    "topic": "Java Syntax",
    "question": "Why is the main method public static void main(String[] args)?",
    "answer": "public means accessible by JVM, static means JVM can call without object, void means no return value, and String[] args stores command line arguments.",
    "details": "JVM needs a fixed entry point to start execution of the program.",
    "example_code": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}"
  },
  {
    "category": "java-programming",
    "level": "Basic",
    "topic": "Variables",
    "question": "What are variables in Java?",
    "answer": "Variables are containers used to store values during program execution.",
    "details": "Java has local variables, instance variables, and static variables.",
    "example_code": "int count = 10; // Local variable\nString message = \"Welcome\"; // Instance variable (if inside class)"
  },
  {
    "category": "java-programming",
    "level": "Basic",
    "topic": "Data Types",
    "question": "What are primitive data types in Java?",
    "answer": "Primitive data types in Java are byte, short, int, long, float, double, char, boolean.",
    "details": "They store actual values directly and are not objects.",
    "example_code": "int age = 25;\ndouble price = 19.99;\nboolean isActive = true;\nchar grade = 'A';"
  },
  {
    "category": "java-programming",
    "level": "Basic",
    "topic": "Type Casting",
    "question": "What is type casting in Java?",
    "answer": "Type casting is converting one data type to another.",
    "details": "There are two types: implicit casting (widening) and explicit casting (narrowing).",
    "example_code": "int a = 10;\ndouble b = a; // Widening (Implicit)\n\ndouble x = 10.5;\nint y = (int) x; // Narrowing (Explicit)"
  },
  {
    "category": "java-programming",
    "level": "Basic",
    "topic": "Operators",
    "question": "What are the types of operators in Java?",
    "answer": "Arithmetic, Relational, Logical, Assignment, Unary, Bitwise, and Ternary operators.",
    "details": "Operators help perform operations like calculation, comparison, and decision making.",
    "example_code": "int a = 10, b = 5;\nint sum = a + b; // Arithmetic\nboolean result = (a > b); // Relational"
  },
  {
    "category": "java-programming",
    "level": "Basic",
    "topic": "Control Statements",
    "question": "What are control statements in Java?",
    "answer": "Control statements are used to control the flow of program execution like if-else, switch, loops, break, continue.",
    "details": "They help in decision making and repetitive execution.",
    "example_code": "if (x > 0) {\n    System.out.println(\"Positive\");\n} else {\n    System.out.println(\"Negative\");\n}"
  },
  {
    "category": "java-programming",
    "level": "Basic",
    "topic": "OOP Concepts",
    "question": "What are the main OOP principles in Java?",
    "answer": "The main OOP principles are Encapsulation, Inheritance, Polymorphism, and Abstraction.",
    "details": "OOP helps write modular, reusable, and maintainable code.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Class and Object",
    "question": "What is the difference between class and object?",
    "answer": "A class is a blueprint that defines properties and behaviors. An object is an instance of a class.",
    "details": "A class does not occupy memory until an object is created.",
    "example_code": "class Car {\n    String model;\n}\n\nCar myCar = new Car(); // Object creation"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Constructor",
    "question": "What is a constructor in Java?",
    "answer": "A constructor is a special method used to initialize objects. It has the same name as the class and no return type.",
    "details": "Constructors can be default, parameterized, and copy constructors (custom implementation).",
    "example_code": "class Student {\n    Student() {\n        System.out.println(\"Constructor Called\");\n    }\n}"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Constructor Overloading",
    "question": "What is constructor overloading?",
    "answer": "Constructor overloading means defining multiple constructors in a class with different parameters.",
    "details": "It helps create objects in different ways depending on requirements.",
    "example_code": "class Box {\n    Box() { }\n    Box(int size) { }\n}"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "this Keyword",
    "question": "What is the use of 'this' keyword in Java?",
    "answer": "'this' refers to the current object of the class.",
    "details": "It is used to refer instance variables, call constructors, and pass current object as parameter.",
    "example_code": "class Employee {\n    int id;\n    Employee(int id) {\n        this.id = id;\n    }\n}"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Inheritance",
    "question": "What is inheritance in Java?",
    "answer": "Inheritance is an OOP concept where a class acquires properties and behaviors of another class using the 'extends' keyword.",
    "details": "It improves code reusability and supports method overriding.",
    "example_code": "class Animal { }\nclass Dog extends Animal { }"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Types of Inheritance",
    "question": "What types of inheritance are supported in Java?",
    "answer": "Java supports Single, Multilevel, and Hierarchical inheritance using classes.",
    "details": "Java does not support multiple inheritance with classes, but supports it through interfaces.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Method Overloading",
    "question": "What is method overloading in Java?",
    "answer": "Method overloading means defining multiple methods with the same name but different parameters.",
    "details": "Overloading happens at compile time, so it is called Compile-time Polymorphism.",
    "example_code": "void print(int a) { }\nvoid print(String b) { }"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Method Overriding",
    "question": "What is method overriding in Java?",
    "answer": "Method overriding means redefining a parent class method in the child class with the same signature.",
    "details": "Overriding happens at runtime, so it is called Runtime Polymorphism.",
    "example_code": "class Parent {\n    void show() { }\n}\nclass Child extends Parent {\n    @Override\n    void show() { }\n}"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "super Keyword",
    "question": "What is the use of 'super' keyword in Java?",
    "answer": "'super' is used to refer to parent class members like variables, methods, and constructors.",
    "details": "It helps access parent class implementation in child class.",
    "example_code": "class Child extends Parent {\n    Child() {\n        super(); // Calls Parent constructor\n    }\n}"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Abstraction",
    "question": "What is abstraction in Java?",
    "answer": "Abstraction means hiding internal implementation details and showing only essential features.",
    "details": "It can be achieved using abstract classes and interfaces.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Abstract Class",
    "question": "What is an abstract class?",
    "answer": "An abstract class is a class that cannot be instantiated and may contain abstract methods and concrete methods.",
    "details": "It is used when multiple related classes share common behavior.",
    "example_code": "abstract class Shape {\n    abstract void draw();\n}"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Interface",
    "question": "What is an interface in Java?",
    "answer": "An interface is a blueprint of a class that contains abstract methods and constants.",
    "details": "Interfaces support multiple inheritance and help achieve full abstraction.",
    "example_code": "interface Printable {\n    void print();\n}"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Encapsulation",
    "question": "What is encapsulation?",
    "answer": "Encapsulation means wrapping data and methods together in a class and restricting access using private fields and public getters/setters.",
    "details": "It improves security and control of data.",
    "example_code": "class User {\n    private String name;\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n}"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Polymorphism",
    "question": "What is polymorphism in Java?",
    "answer": "Polymorphism means one method or object behaves differently in different situations.",
    "details": "Types: compile-time polymorphism (overloading) and runtime polymorphism (overriding).",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Exception Handling",
    "question": "What is exception handling in Java?",
    "answer": "Exception handling is a mechanism to handle runtime errors using try, catch, finally, throw, and throws.",
    "details": "It prevents program termination and allows graceful error recovery.",
    "example_code": "try {\n    int data = 10 / 0;\n} catch (ArithmeticException e) {\n    System.out.println(e);\n}"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Checked vs Unchecked Exception",
    "question": "What is the difference between checked and unchecked exceptions?",
    "answer": "Checked exceptions are checked at compile time (e.g., IOException). Unchecked exceptions are checked at runtime (e.g., NullPointerException).",
    "details": "Checked exceptions must be handled using try-catch or throws.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Multithreading",
    "question": "What is multithreading in Java?",
    "answer": "Multithreading is a feature that allows multiple threads to run concurrently to improve performance and responsiveness.",
    "details": "Threads can be created using Thread class or Runnable interface.",
    "example_code": "class MyThread extends Thread {\n    public void run() { System.out.println(\"Running\"); }\n}"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Thread vs Runnable",
    "question": "What is the difference between Thread and Runnable?",
    "answer": "Thread is a class, Runnable is an interface. Runnable is preferred because Java supports single inheritance and Runnable allows extending another class.",
    "details": "Runnable separates task logic from thread execution.",
    "example_code": "Runnable task = () -> System.out.println(\"Running task\");\nnew Thread(task).start();"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Synchronization",
    "question": "What is synchronization in Java?",
    "answer": "Synchronization is a technique used to control access to shared resources by multiple threads to avoid inconsistency.",
    "details": "It can be achieved using synchronized methods or synchronized blocks.",
    "example_code": "synchronized void printTable(int n) {\n    // code\n}"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Collection Framework",
    "question": "What is the Java Collection Framework?",
    "answer": "Java Collection Framework provides classes and interfaces to store and manipulate groups of objects like List, Set, Queue, and Map.",
    "details": "It includes implementations like ArrayList, HashSet, LinkedList, HashMap.",
    "example_code": "List<String> list = new ArrayList<>();\nlist.add(\"Java\");"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "ArrayList vs LinkedList",
    "question": "What is the difference between ArrayList and LinkedList?",
    "answer": "ArrayList uses dynamic array and provides fast random access. LinkedList uses doubly linked list and provides faster insertion/deletion.",
    "details": "ArrayList is better for retrieval, LinkedList is better for frequent insert/delete operations.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "HashMap Working",
    "question": "How does HashMap work internally?",
    "answer": "HashMap stores key-value pairs using hashing. Keys are converted into hash codes and mapped to buckets where values are stored.",
    "details": "In case of collision, it uses linked list or balanced tree (after Java 8) to store multiple entries in the same bucket.",
    "example_code": "Map<Integer, String> map = new HashMap<>();\nmap.put(1, \"Apple\");"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "equals() and hashCode()",
    "question": "Why should equals() and hashCode() be overridden together?",
    "answer": "Because if two objects are equal using equals(), they must have the same hashCode to work correctly in HashMap and HashSet.",
    "details": "If hashCode differs for equal objects, collections may not find the object correctly.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Java 8 Features",
    "question": "What are important Java 8 features?",
    "answer": "Important Java 8 features include Lambda Expressions, Functional Interfaces, Stream API, Default Methods, Method References, and Optional class.",
    "details": "Java 8 introduced functional programming style in Java.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Lambda Expression",
    "question": "What is a Lambda expression?",
    "answer": "A lambda expression is an anonymous function that provides a concise way to implement functional interfaces.",
    "details": "Syntax: (parameters) -> expression",
    "example_code": "Runnable r = () -> System.out.println(\"Thread running...\");\nnew Thread(r).start();"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Stream API",
    "question": "What is Stream API in Java?",
    "answer": "Stream API is used to process collections in a functional style using operations like filter, map, reduce, and collect.",
    "details": "Streams do not store data, they process data from a source like collections or arrays.",
    "example_code": "List<String> names = Arrays.asList(\"John\", \"Jane\", \"Adam\");\nnames.stream().filter(n -> n.startsWith(\"J\")).forEach(System.out::println);"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Serialization",
    "question": "What is serialization in Java?",
    "answer": "Serialization is the process of converting an object into a byte stream so it can be saved to file or transferred over network.",
    "details": "Deserialization converts byte stream back into object.",
    "example_code": "class Employee implements Serializable { \n    int id; \n    String name; \n}"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Garbage Collection",
    "question": "What is garbage collection in Java?",
    "answer": "Garbage collection is an automatic memory management process where JVM removes unused objects from heap memory.",
    "details": "It prevents memory leaks and improves performance.",
    "example_code": "System.gc(); // Requesting garbage collection (not guaranteed)"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "String vs StringBuilder vs StringBuffer",
    "question": "What is the difference between String, StringBuilder, and StringBuffer?",
    "answer": "String is immutable. StringBuilder is mutable and not thread-safe. StringBuffer is mutable and thread-safe.",
    "details": "Use StringBuilder for performance in single-thread, StringBuffer for multi-thread environments.",
    "example_code": "String s = \"Hello\";\nStringBuilder sb = new StringBuilder(\"Hello\");\nsb.append(\" World\");"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "JVM Memory Areas",
    "question": "What are the main memory areas in JVM?",
    "answer": "Main memory areas are Heap, Stack, Method Area, Program Counter Register, and Native Method Stack.",
    "details": "Heap stores objects, Stack stores method calls and local variables.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Singleton Pattern",
    "question": "How do you create a Singleton class in Java?",
    "answer": "Make the constructor private, create a static instance variable, and provide a public static method to return that instance.",
    "details": "Ensures only one instance of the class exists.",
    "example_code": "class Singleton {\n    private static Singleton obj = new Singleton();\n    private Singleton() {}\n    public static Singleton get() { return obj; }\n}"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Volatile Keyword",
    "question": "What is the 'volatile' keyword?",
    "answer": "Volatile is used to mark a variable as being stored in main memory. It guarantees visibility of changes to variables across threads.",
    "details": "Prevents threads from caching variables locally.",
    "example_code": "private volatile boolean running = true;"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Transient Keyword",
    "question": "What is the 'transient' keyword used for?",
    "answer": "Transient keyword is used in serialization to indicate that a variable should not be serialized.",
    "details": "The value of a transient variable will be null/default after deserialization.",
    "example_code": "transient int password;"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Functional Interface",
    "question": "What is a Functional Interface?",
    "answer": "An interface that contains exactly one abstract method. It can have default and static methods.",
    "details": "They are the basis for Lambda expressions. Annotation @FunctionalInterface is optional but good practice.",
    "example_code": "@FunctionalInterface\ninterface Calculator {\n    int add(int a, int b);\n}"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Comparator vs Comparable",
    "question": "Difference between Comparable and Comparator?",
    "answer": "Comparable provides default natural sorting order (compareTo method). Comparator provides custom sorting order (compare method).",
    "details": "Comparable affects the original class; Comparator is a separate class/lambda.",
    "example_code": "Collections.sort(list, (a, b) -> a.name.compareTo(b.name)); // Comparator"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Fail-Fast vs Fail-Safe",
    "question": "What is the difference between Fail-Fast and Fail-Safe iterators?",
    "answer": "Fail-Fast iterators throw ConcurrentModificationException if the collection is modified while iterating (e.g., ArrayList). Fail-Safe iterators work on a clone/snapshot and allow modifications (e.g., ConcurrentHashMap).",
    "details": "Fail-Fast uses an internal modCount to detect changes.",
    "example_code": "Iterator<String> it = list.iterator();\nlist.add(\"New\"); // Throws Exception for Fail-Fast"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "ConcurrentHashMap",
    "question": "How is ConcurrentHashMap different from Hashtable?",
    "answer": "Hashtable locks the entire map for thread safety (slow). ConcurrentHashMap locks only specific segments (buckets) or uses CAS (Compare-And-Swap), allowing concurrent reads and updates.",
    "details": "It never throws ConcurrentModificationException.",
    "example_code": "Map<String, String> map = new ConcurrentHashMap<>();"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Deadlock",
    "question": "What is a Deadlock and how can you avoid it?",
    "answer": "Deadlock occurs when two threads are waiting for each other to release a lock, causing them to be stuck forever. It can be avoided by acquiring locks in a consistent order.",
    "details": "Tools like jstack can help detect deadlocks.",
    "example_code": "Thread 1 locks A, waits for B.\nThread 2 locks B, waits for A. // Deadlock"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Executor Framework",
    "question": "What is the Executor Framework?",
    "answer": "It is a framework used to manage a pool of threads effectively instead of manually creating and starting threads.",
    "details": "It decouples task submission from task execution. Common implementations include FixedThreadPool and CachedThreadPool.",
    "example_code": "ExecutorService executor = Executors.newFixedThreadPool(10);\nexecutor.submit(() -> System.out.println(\"Task\"));"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Atomic Variables",
    "question": "What are Atomic variables (e.g., AtomicInteger)?",
    "answer": "Classes in java.util.concurrent.atomic that support lock-free, thread-safe operations on single variables.",
    "details": "They use low-level CPU instructions (CAS) for performance.",
    "example_code": "AtomicInteger count = new AtomicInteger(0);\ncount.incrementAndGet(); // Thread-safe increment"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Classloaders",
    "question": "What are the different types of Classloaders in Java?",
    "answer": "Bootstrap (loads core libs like rt.jar), Extension/Platform (loads libs from ext folder), and System/Application Classloader (loads classes from classpath).",
    "details": "They follow a delegation hierarchy model.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Memory Management",
    "question": "Difference between StackOverflowError and OutOfMemoryError?",
    "answer": "StackOverflowError occurs when the stack memory is full (often due to infinite recursion). OutOfMemoryError occurs when the Heap memory is full (too many objects).",
    "details": "Stack stores method calls; Heap stores objects.",
    "example_code": "public void recursive() { recursive(); } // Causes StackOverflowError"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Java 8 Memory",
    "question": "What is the difference between PermGen and Metaspace?",
    "answer": "PermGen was the method area in Java 7 (fixed size). Metaspace replaced it in Java 8 and uses native memory (auto-resizable).",
    "details": "This reduces the chance of OutOfMemoryError: PermGen space.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "References",
    "question": "What is the difference between WeakReference and SoftReference?",
    "answer": "WeakReference objects are collected eagerly by GC. SoftReference objects are collected only when JVM runs out of memory.",
    "details": "SoftReference is often used for implementing caches.",
    "example_code": "WeakReference<Student> weak = new WeakReference<>(new Student());"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "JIT Compiler",
    "question": "What is the JIT (Just-In-Time) Compiler?",
    "answer": "JIT is a component of the JVM that optimizes performance by compiling bytecode into native machine code at runtime.",
    "details": "It identifies 'hot spots' (frequently called methods) to optimize.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Marker Interface",
    "question": "What is a Marker Interface?",
    "answer": "An interface with no methods or constants. It signals the JVM or compiler to perform some special operation.",
    "details": "Examples: Serializable, Cloneable, Remote.",
    "example_code": "public interface Serializable { }"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Cloning",
    "question": "Difference between Shallow Copy and Deep Copy?",
    "answer": "Shallow copy copies the object but references internal objects. Deep copy copies the object and creates new copies of all internal objects.",
    "details": "Default clone() does a shallow copy.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Memory Leaks",
    "question": "What are common causes of Memory Leaks in Java?",
    "answer": "Static collections (hashmaps) growing indefinitely, unclosed resources (streams/connections), and improper equals/hashCode implementations.",
    "details": "Objects in static fields stay in memory for the life of the application.",
    "example_code": "static List<Object> leak = new ArrayList<>(); // Never cleared"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Externalization",
    "question": "What is Externalizable interface?",
    "answer": "It extends Serializable and allows the programmer to control the reading and writing of objects completely using writeExternal() and readExternal().",
    "details": "It is faster than Serialization but requires more code.",
    "example_code": "public void writeExternal(ObjectOutput out) throws IOException { ... }"
  },
  {
    "category": "java-programming",
    "level": "Basic",
    "topic": "Finalize",
    "question": "What is the finalize() method?",
    "answer": "It was a method used to perform cleanup before an object is garbage collected. It is now deprecated in newer Java versions (Java 9+).",
    "details": "Use try-with-resources or Cleaner instead.",
    "example_code": "protected void finalize() { System.out.println(\"Removed\"); }"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Thread Communication",
    "question": "Difference between wait() and sleep()?",
    "answer": "wait() releases the lock and waits for notification. sleep() pauses execution but keeps the lock.",
    "details": "wait() is an Object method; sleep() is a Thread static method.",
    "example_code": "synchronized(obj) { obj.wait(); } // Releases lock"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Locks",
    "question": "Difference between synchronized and ReentrantLock?",
    "answer": "synchronized is implicit and block-based. ReentrantLock provides more flexibility, like fairness policies, tryLock(), and interruptible locking.",
    "details": "ReentrantLock must be explicitly unlocked in a finally block.",
    "example_code": "lock.lock(); try { ... } finally { lock.unlock(); }"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Thread Communication",
    "question": "Difference between notify() and notifyAll()?",
    "answer": "notify() wakes up a single random thread waiting on the object's monitor. notifyAll() wakes up all waiting threads.",
    "details": "notifyAll() is safer to avoid missed signals.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "ThreadLocal",
    "question": "What is ThreadLocal?",
    "answer": "It provides thread-local variables. Each thread accessing the variable has its own, independently initialized copy.",
    "details": "Useful for storing transaction IDs or user sessions per thread.",
    "example_code": "ThreadLocal<Integer> threadId = ThreadLocal.withInitial(() -> 1);"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "CountDownLatch",
    "question": "What is CountDownLatch?",
    "answer": "A synchronizer that allows one or more threads to wait until a set of operations being performed in other threads completes.",
    "details": "The count cannot be reset once it reaches zero.",
    "example_code": "CountDownLatch latch = new CountDownLatch(3); \nlatch.await(); // Waits for count to be 0"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "CyclicBarrier",
    "question": "Difference between CountDownLatch and CyclicBarrier?",
    "answer": "CountDownLatch cannot be reused. CyclicBarrier can be reused after the waiting threads are released.",
    "details": "CyclicBarrier waits for a fixed number of threads to reach a common barrier point.",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Callable vs Runnable",
    "question": "Difference between Callable and Runnable?",
    "answer": "Runnable does not return a result and cannot throw checked exceptions. Callable returns a result and can throw exceptions.",
    "details": "Callable is used with ExecutorService to get a Future.",
    "example_code": "Callable<Integer> task = () -> { return 10; };"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "BlockingQueue",
    "question": "What is BlockingQueue used for?",
    "answer": "It is a thread-safe queue that supports operations that wait for the queue to become non-empty when retrieving, and non-full when storing.",
    "details": "Ideal for Producer-Consumer problems.",
    "example_code": "BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Future",
    "question": "What is a Future object?",
    "answer": "It represents the result of an asynchronous computation. You can check if the task is done, wait for completion, and retrieve the result.",
    "details": "Obtained when submitting a Callable to an Executor.",
    "example_code": "Future<Integer> future = executor.submit(callableTask);\nInteger result = future.get();"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Race Condition",
    "question": "What is a Race Condition?",
    "answer": "A situation where two or more threads access shared data concurrently and try to change it at the same time, leading to unpredictable results.",
    "details": "Prevented using synchronization or atomic variables.",
    "example_code": "if (x == 5) // Thread 1 checks\n   y = x * 2; // Thread 2 changes x before this line"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Design Patterns",
    "question": "What is the Factory Design Pattern?",
    "answer": "A creational pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.",
    "details": "Used when the exact type of object isn't known until runtime.",
    "example_code": "Shape s = ShapeFactory.getShape(\"CIRCLE\");"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Design Patterns",
    "question": "What is the Observer Design Pattern?",
    "answer": "A behavioral pattern where an object (Subject) maintains a list of dependents (Observers) and notifies them of any state changes.",
    "details": "Used in event handling systems (e.g., Listener in Swing/JS).",
    "example_code": "Not required"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Design Patterns",
    "question": "How do you create an Immutable Class?",
    "answer": "Declare class as final, make fields private and final, provide no setters, and initialize all fields via constructor.",
    "details": "If fields are mutable objects, return deep copies in getters.",
    "example_code": "final class User {\n    private final String name;\n    public User(String name) { this.name = name; }\n}"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Design Patterns",
    "question": "What is the Builder Design Pattern?",
    "answer": "A creational pattern used to construct a complex object step by step. It separates the construction of a complex object from its representation.",
    "details": "Useful when a class has many constructor parameters.",
    "example_code": "User u = new User.Builder().setName(\"John\").setAge(25).build();"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Java 8 Streams",
    "question": "Difference between map() and flatMap()?",
    "answer": "map() transforms each element into a single value. flatMap() transforms each element into a stream of values and flattens them into a single stream.",
    "details": "map: One-to-One. flatMap: One-to-Many.",
    "example_code": "List<String> words = list.stream().flatMap(line -> Arrays.stream(line.split(\" \"))).collect(Collectors.toList());"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Functional Interfaces",
    "question": "What are Predicate, Consumer, Supplier, and Function?",
    "answer": "Core functional interfaces: Predicate (returns boolean), Consumer (accepts arg, returns void), Supplier (returns result, no args), Function (accepts arg, returns result).",
    "details": "Used extensively in Streams.",
    "example_code": "Predicate<String> isLong = s -> s.length() > 5;"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Java 8 Features",
    "question": "What is a Method Reference?",
    "answer": "Shorthand syntax for a lambda expression that executes just one existing method.",
    "details": "Syntax: ClassName::methodName",
    "example_code": "list.forEach(System.out::println);"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Parallel Stream",
    "question": "What is a Parallel Stream?",
    "answer": "A stream that splits elements into multiple chunks and processes them in parallel using the Fork/Join framework.",
    "details": "Use .parallelStream() for large datasets, but be careful of thread safety.",
    "example_code": "list.parallelStream().filter(e -> e > 10).count();"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Database",
    "question": "Difference between Statement and PreparedStatement?",
    "answer": "Statement is used for general SQL queries. PreparedStatement is precompiled and used for queries with parameters.",
    "details": "PreparedStatement prevents SQL Injection and is faster for repeated execution.",
    "example_code": "PreparedStatement ps = con.prepareStatement(\"SELECT * FROM users WHERE id = ?\");"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Interfaces",
    "question": "How does Java resolve the Diamond Problem with default methods?",
    "answer": "If a class implements two interfaces with the same default method, the class must override the method to resolve the conflict.",
    "details": "You can call a specific interface's method using InterfaceName.super.method().",
    "example_code": "public void show() { InterfaceA.super.show(); }"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Keywords Distinction",
    "question": "What is the difference between final, finally, and finalize?",
    "answer": "final is a keyword to apply restrictions on classes, methods, and variables. finally is a block used in exception handling to execute code regardless of errors. finalize is a method used for garbage collection cleanup (deprecated).",
    "details": "They sound similar but serve completely different purposes.",
    "example_code": "final int x = 10; \ntry { } finally { System.out.println(\"Done\"); }"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "String Interning",
    "question": "What does the String intern() method do?",
    "answer": "It returns the canonical representation of the string from the String Constant Pool. If the pool already contains a string equal to this object, it returns the pool's string; otherwise, it adds this string to the pool.",
    "details": "Useful for saving memory when you have many duplicate strings created via 'new'.",
    "example_code": "String s1 = new String(\"Hello\");\nString s2 = s1.intern(); // Returns reference from Pool"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Data Types & Precision",
    "question": "Why should you use BigDecimal instead of Double for financial calculations?",
    "answer": "Double uses floating-point arithmetic which can result in precision loss (e.g., 0.1 + 0.2 != 0.3). BigDecimal provides arbitrary-precision arithmetic needed for accurate currency calculations.",
    "details": "Always use the String constructor for BigDecimal to avoid initial precision loss.",
    "example_code": "BigDecimal payment = new BigDecimal(\"100.50\");"
  },
  {
    "category": "java-programming",
    "level": "Intermediate",
    "topic": "Initialization Blocks",
    "question": "What is the difference between Static Block and Instance Initialization Block?",
    "answer": "Static blocks execute once when the class is loaded. Instance initialization blocks execute every time an instance of the class is created, before the constructor.",
    "details": "Static blocks are used for static variable initialization; Instance blocks for common code across all constructors.",
    "example_code": "static { System.out.println(\"Static\"); }\n{ System.out.println(\"Instance\"); }"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Covariant Return Type",
    "question": "What is Covariant Return Type?",
    "answer": "It allows an overriding method in a child class to return a subtype of the return type declared in the parent class method.",
    "details": "Before Java 5, the return type had to be exactly the same.",
    "example_code": "class A { A get() { return this; } }\nclass B extends A { @Override B get() { return this; } }"
  },
  {
    "category": "java-programming",
    "level": "Advanced",
    "topic": "Integer Caching",
    "question": "Explain Java Integer Caching.",
    "answer": "Java caches Integer objects from -128 to 127. If you create Integers within this range using autoboxing or Integer.valueOf(), you get the same object reference.",
    "details": "Comparing Integers outside this range using '==' will return false.",
    "example_code": "Integer a = 100, b = 100;\nSystem.out.println(a == b); // true\nInteger x = 200, y = 200;\nSystem.out.println(x == y); // false"
  }
]

